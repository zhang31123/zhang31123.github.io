<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SpringBoot集成ZK框架实现前后台无js代码交互]]></title>
    <url>%2F2019%2F05%2F25%2FSpringBoot%E9%9B%86%E6%88%90ZK%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0%E5%89%8D%E5%90%8E%E5%8F%B0%E6%97%A0js%E4%BB%A3%E7%A0%81%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[Spring Initializr 一个springboot项目2. 配置pom.xml引入Springboot和ZK的依赖。 4.0.0 spring.zk zkspringboot-demo-test jar 0.0.1-SNAPSHOT zkspringboot-demo-test http://www.zkoss.org &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;ZK CE&lt;/id&gt; &lt;name&gt;ZK CE Repository&lt;/name&gt; &lt;url&gt;https://mavensync.zkoss.org/maven2&lt;/url&gt; &lt;/repository&gt; &lt;repository&gt; &lt;id&gt;ZK EVAL&lt;/id&gt; &lt;name&gt;ZK Evaluation Repository&lt;/name&gt; &lt;url&gt;https://mavensync.zkoss.org/eval&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;zkspringboot.version&gt;1.0.4&lt;/zkspringboot.version&gt; &lt;springboot.version&gt;2.1.0.RELEASE&lt;/springboot.version&gt; &lt;zk.version&gt;8.6.0.1-Eval&lt;/zk.version&gt; &lt;zats.version&gt;2.0.0&lt;/zats.version&gt; &lt;junit.version&gt;4.12&lt;/junit.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.zkoss.zkspringboot&lt;/groupId&gt; &lt;artifactId&gt;zkspringboot-starter&lt;/artifactId&gt; &lt;version&gt;${zkspringboot.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.zkoss.zk&lt;/groupId&gt; &lt;artifactId&gt;zkmax&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-jdk14&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.zkoss.zk&lt;/groupId&gt; &lt;artifactId&gt;zkbind&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.zkoss.zk&lt;/groupId&gt; &lt;artifactId&gt;zuti&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.zkoss.zk&lt;/groupId&gt; &lt;artifactId&gt;zkplus&lt;/artifactId&gt; &lt;version&gt;${zk.version}&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${springboot.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; 编写springboot入口类: package spring.zk.test; import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.GetMapping; @SpringBootApplication@Controllerpublic class TestApplication { public static void main(String[] args) { SpringApplication.run(TestApplication.class); } @GetMapping(&quot;/mvvm&quot;) public String mvvmExample() { return &quot;mvvm&quot;; } } 编写 TestService 类 获取当前时间: package spring.zk.test.service; import org.springframework.stereotype.Service; import java.util.Date; @Servicepublic class TestService { public Date getTime() { return new Date(); }} 编写 MainViewModel 类: package spring.zk.test.viewmodel; import org.zkoss.bind.annotation.Command;import org.zkoss.bind.annotation.NotifyChange;import org.zkoss.zk.ui.select.annotation.VariableResolver;import org.zkoss.zk.ui.select.annotation.WireVariable;import org.zkoss.zkplus.spring.DelegatingVariableResolver;import spring.zk.test.service.TestService; import java.util.Date; @VariableResolver(DelegatingVariableResolver.class)public class MainViewModel { @WireVariable private TestService testService; @Command @NotifyChange(&quot;currentTime&quot;) public void updateTime() { //只刷新变量 NotifyChange currentTime } public Date getCurrentTime() { return testService.getTime(); } } 编写前端界面mvvm.zul，@init引入后台MainViewModel类， 实现前后台变量的绑定，onClick=”@command(‘updateTime’)” 绑定后台updateTime方法，实现前后台交互: Current Time (from Spring Service): 编写springboot 的配置文件application.properties: server.port=8888 Enable zulzk.zul-view-resolver-prefix=/zul 运行SpringBoot项目: 访问项目：10.刷新时间]]></content>
  </entry>
  <entry>
    <title><![CDATA[新装服务器、终端配置局域网]]></title>
    <url>%2F2019%2F05%2F25%2F%E6%96%B0%E8%A3%85%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%81%E7%BB%88%E7%AB%AF%E9%85%8D%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%2F</url>
    <content type="text"><![CDATA[新装服务器、终端配置局域网 我们给一台服务器装完系统之后往往需要设置局域网，网络设置步骤如下。 确定是哪个网口，右下角网络连接能看到网卡名字。 停掉network-manager服务 1#/etc/init.d/network-manager stop 禁用network-manager #systemctl disable network-manager 在/etc/network/interfaces里配置ip，网卡，子网掩码,网关等信息。 #vim /etc/network/interfaces5. 重启 networking服务 #/etc/init.d/networking restart这几个步骤简简单单就配置好了。]]></content>
  </entry>
  <entry>
    <title><![CDATA[vmware'如果已在 BIOS-固件设置中禁用 Intel VT-x，或主机自更改此设置后从未重新启动，则 Intel VT-x 可能被禁用'解决办法]]></title>
    <url>%2F2019%2F05%2F25%2Fvmware'%E5%A6%82%E6%9E%9C%E5%B7%B2%E5%9C%A8%20BIOS-%E5%9B%BA%E4%BB%B6%E8%AE%BE%E7%BD%AE%E4%B8%AD%E7%A6%81%E7%94%A8%20Intel%20VT-x%EF%BC%8C%E6%88%96%E4%B8%BB%E6%9C%BA%E8%87%AA%E6%9B%B4%E6%94%B9%E6%AD%A4%E8%AE%BE%E7%BD%AE%E5%90%8E%E4%BB%8E%E6%9C%AA%E9%87%8D%E6%96%B0%E5%90%AF%E5%8A%A8%EF%BC%8C%E5%88%99%20Intel%20VT-x%20%E5%8F%AF%E8%83%BD%E8%A2%AB%E7%A6%81%E7%94%A8'%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以前装了个vmware，里面安装了Ubuntu Linux的系统，突然想研究下Docker,却发现虚拟机打不开了，提示‘如果已在 BIOS/固件设置中禁用 Intel VT-x，或主机自更改此设置后从未重新启动，则 Intel VT-x 可能被禁用’ 原因：系统的Intel 虚拟技术没开 解决办法： 重启计算机，进入BIOS设置， 把configuration下的Intel Virtual Technology设置为Enable。 按F10保存设置。 电脑开机后，打开vmware，然后开启虚拟机。 进入虚拟机成功。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 项目配置]]></title>
    <url>%2F2019%2F05%2F25%2FSpring%20Boot%20%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1 . 端口配置，在application.yml里设置server.port属性 配置context-path,如果不配置context-path，访问路径是localhost:8081/hello 如果配置context-path: /test, 那么访问路径就变换成localhost:8081/test/hello 属性注入 配置里使用配置 对象属性注入 开发环境与生产环境区分]]></content>
  </entry>
  <entry>
    <title><![CDATA[运行你的第一个Docker镜像]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%BF%90%E8%A1%8C%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AADocker%E9%95%9C%E5%83%8F%2F</url>
    <content type="text"><![CDATA[首先我们先编写一个简单的java spring boot 程序，并打成jar包 2. 把这个jar包copy到装有docker 环境的虚拟机里 docker查找jre基础镜像 下载该镜像到本地镜像仓库 查看下载下来的基础jre镜像 编写 Dockerfile文件 注意: Dockerfile 必须要跟test-0.0.1-SNAPSHOT.jar在同一个目录 名字必须叫Dockerfile FROM：刚下载下来的jre基础镜像MAINTAINER：维护者信息ADD: 把本地文件添加到容器内的哪个位置ENV 设置环境变量workdir 工作空间EXPOSE 运行容器的端口CMD 启动指令编写完Dockerfile保存退出 创建镜像 docker build -t test:0.0.0.1 .注意：不要忘记了后边的 . docker images 查看刚创建的镜像 运行该镜像， 因为我在程序的里指定了端口 server.port=8082，所以容器内的端口是8082， 我们把它映射到外边的12888端口 执行docker run -d -p 12888:8082 test:0.0.0.1 运行该镜像 docker ps 查看正在运行的镜像 浏览器访问该程序]]></content>
  </entry>
  <entry>
    <title><![CDATA[Docker 批量操作]]></title>
    <url>%2F2019%2F05%2F25%2FDocker%20%E6%89%B9%E9%87%8F%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[docker 查看所有容器docker ps -a docker 批量删除容器docker rm -f $(docker ps -a -q) 在日常操作中，我们通常是版本迭代的去打镜像，知道镜像能用为止， 这样，本地就会有多个版本的镜像，docker rmi命令可以批量删除无用的镜像，只保留本地有用的一个版本 先创建几个版本的镜像方便演示 假设只有版本0.0.0.1 能用， 我们要保留testdemo:0.0.0.1，删除其他版本的镜像 假设我们有一个主控节点服务器master1, 有15个 计算节点服务器，我们可以在主控节点用以下命令往各个节点拉镜像，这样启动部署容器的时候不管它跳到哪个节点运行，都省掉了pull的时间，以免造成超时。]]></content>
  </entry>
  <entry>
    <title><![CDATA[myql GROU_CONCAT 与FIND_IN_SET查询结果为空问题解决]]></title>
    <url>%2F2019%2F05%2F25%2Fmyql%20GROU_CONCAT%20%E4%B8%8EFIND_IN_SET%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E4%B8%BA%E7%A9%BA%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[有两张表，表结构如下,右边是hot_incident数据 hot_event_person_ids以字符串的形式存多个hot_person表里的id hot_person数据如下 需求： 根据hot_person表里id为2的用户与hot_incident.hot_event_person_ids对应的所有的incident_title的拼接，中间用逗号隔开 实现：SELECT hp.id id, hp.NAME NAME, ‘事件人物’ AS labelName, hp.keyword AS keyword, GROUP_CONCAT(hi.incident_title)FROM hot_person hp, hot_incident hiWHERE hp.STATUS = 1 AND hp.id = 2 AND FIND_IN_SET(hp.id, hi.hot_event_person_ids)； 发现查出的是null 排查原因，发现是hot_person表的id创建的时候设置了fillzero属性，解决方案：1. 去掉hot_person表id 的fillzero属性解决方案： 2. hot_incident.hot_event_person_ids存id的时候补零。 解决后效果：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F05%2F25%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
